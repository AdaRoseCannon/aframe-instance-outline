var AFRAME_OUTLINE=function(t,n){"use strict";const e=new n.Matrix4,i=new n.Matrix4,r=[];class o extends n.SkinnedMesh{constructor(t,e,i){super(t,e),this.instanceMatrix=new n.InstancedBufferAttribute(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1,this._mesh=null}copy(t){return super.copy(t),t.isInstancedMesh&&(this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count),this}getColorAt(t,n){n.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,n){n.fromArray(this.instanceMatrix.array,16*t)}raycast(t,o){const a=this.matrixWorld,s=this.count;null===this._mesh&&(this._mesh=new n.SkinnedMesh(this.geometry,this.material),this._mesh.copy(this));const c=this._mesh;if(void 0!==c.material)for(let n=0;n<s;n++){this.getMatrixAt(n,e),i.multiplyMatrices(a,e),c.matrixWorld=i,c.raycast(t,r);for(let t=0,e=r.length;t<e;t++){const e=r[t];e.instanceId=n,e.object=this,o.push(e)}r.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new n.InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,n){n.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function a(t){t.vertexShader=t.vertexShader.replace("void main() {","\n\t#include <normal_pars_vertex>\n\tflat varying float instanceID;\n\t#ifdef FLAT_SHADED\n\t\tvarying vec3 vNormal;\n\t#endif\n\t#ifdef USE_ENVMAP\n\t\t#ifndef ENV_WORLDPOS\n\t\t\tvarying vec3 vWorldPosition;\n\t\t#endif\n\t#else\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\tvoid main() {\n\t"),t.vertexShader=t.vertexShader.replace("#include <project_vertex>","\n\tinstanceID = float(gl_InstanceID);\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#ifdef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\tvec4 mvPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tmvPosition = instanceMatrix * mvPosition;\n\t#endif\n\tmvPosition = modelViewMatrix * mvPosition;\n\tmvPosition += vec4(vNormal * 0.015 * instanceID, .0);\n\tgl_Position = projectionMatrix * mvPosition;\n\t"),t.fragmentShader=t.fragmentShader.replace("void main() {","\n\t#ifdef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#endif\n\tflat varying float instanceID;\n\tuniform mat4 modelViewMatrix;\n\t#ifdef USE_ENVMAP\n\t#ifndef ENV_WORLDPOS\n\tvarying vec3 vWorldPosition;\n\t#endif\n\t#else\n\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifndef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n\t#endif\n\tvoid main() {\n\t\t#include <normal_fragment_begin>\n\t\tvec4 posInView = modelViewMatrix * vec4(vWorldPosition, 1.0);\n\t\tposInView /= posInView[3];\n\t\tvec3 VinView = normalize(-posInView.xyz);\n\t\tif (instanceID == 1. && dot(VinView, vNormal) > .3) discard;\n"),t.fragmentShader=t.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n\tvec4 diffuseColor = vec4(mix(vec3(0.), vec3(1.), instanceID), opacity);\n\t")}o.prototype.isInstancedMesh=!0;const s=(new THREE.Matrix4).makeScale(1,1,1);function c(t){const n=[];t.traverse((t=>{if(t instanceof THREE.Mesh&&!(t instanceof THREE.InstancedMesh||t instanceof o)){const e=new THREE.MeshBasicMaterial({color:t.material.color,onBeforeCompile:a,side:THREE.DoubleSide,transparent:!1,blending:THREE.AdditiveBlending}),i=t instanceof THREE.SkinnedMesh?new o(t.geometry,e,2):new THREE.InstancedMesh(t.geometry,e,2);t.updateMatrixWorld(),i.setMatrixAt(0,s),i.setMatrixAt(1,s);const r=t.parent.children,c=r.indexOf(t);i.children=t.children,i.parent=t.parent,n.push((()=>r[c]=i))}}));for(const t of n)t()}return AFRAME.registerComponent("outline",{schema:{},init(){this.onLoad=()=>c(this.el.object3D),this.el.addEventListener("object3dset",this.onLoad),this.onLoad()}}),t.makeOutline=c,t.onBeforeCompile=a,Object.defineProperty(t,"__esModule",{value:!0}),t}({},THREE);
//# sourceMappingURL=aframe-instance-outline.min.js.map
